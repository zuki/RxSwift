## ReactiveCocoaとの比較

RxSwiftはReactiveCocoaにある程度似ています。ReactiveCocoaはRxから数多くの概念を借りている
からです。

RxSwiftの主たる目標の一つは、他のRx実装と足並みをそろえた極めてシンプルなインターフェースの作成、豊かな並行処理モデルの提供、より多くの最適化のチャンスとSwiftに備わっているエラーハンドリング機構とのより良い整合性の提供を行うことでした。

また、我々はSwift/llvmコンパイラーのみに頼り、外部依存性はいっさい導入しないと決めました。

おそらくRxSwiftとReactiveCocoaの主たる違いは抽象化を構築するアプローチにあります。

RxSwiftの主たる目標は、observableシーケンスという形の抽象化された、環境にとらわれない合成計算(composition computation)グルーを提供することです。そして特定のプラットフォームでRxSwiftを使用する体験を向上させることをめざしています。これを実現するために、RxCocoaは汎用計算(generic cumputation)を使用し、より実用的な抽象化を構築し、Foundation/Cocoa/UKitフレームワークをラップしています。これは外部のライブラリーが汎用計算エンジンにコンテキストとセマンティクスを与えることを意味しています。一方、RxSwiftは`Driver`、`ControlProperty`、`ControlEvent`などを提供しています。

これら抽象化のすべてを一つの概念、すなわち`observableシーケンス`で表すことの利点の一つは、これらの上で構築したすべての計算抽象化も、同じ基本的な方法で構成できることです。両者はすべて同じ規約に従い、同じインターフェースを実装します。また、柔軟なサブスクリプション（リソース）共有戦略を作成したり、もビルトインの関数、`share`, `shareReplay`, `publish`, `multicast`, `shareReplayLatestWhileConnected`などを使うことも容易です。

このライブラリは微調整可能な並行処理モデルも提供しています。コンカレントスケジューラーが使用される場合、observableシーケンスオペレーターはシーケンスのプロパティを保持します。observableシーケンスオペレーターは既知のシリアルスケジュールを検出して最適に利用する方法も知っています。ReactiveCocoaの並行処理モデルはもっと制限されており、シリアルスケジューラーしか許可されていません。

マルチスレッドプログラミングは本当に難しく、非自明なループを検出するのは更に難しくなります。  
これは全てのオペレーターがフォールトトレラントな方法で構築されている理由です。たとえ、要素の生成が要素の処理中に発生（再帰）しても、オペレーターはそのような状況に対処してデッドロックを防ごうとします。これは、最悪の場合プログラミングエラーがスタックオーバーフローを引き起こしても、ユーザは手動でアプリケーションを終了させる必要はなく、エラーリポートシステムのクラッシュリポートを取得し、問題を発見して修正できることを意味します。
