## ReactiveCocoaとの比較

ReactiveCocoaがRxから多くの概念を借り入れて以来、RxSwiftはReactiveCocoaとやや似ています。

このプロジェクトの主な目標の一つは、豊かな同時実行モデルを提供し、より最適化のチャンスを提供し、  
Swiftビルドインのエラーハンドリング機構により整合し、他のRx実装により整合する大幅に簡素化したインターフェースを作ることでした。

我々はまたSwift/llvmコンパイラーのみに頼り、任意の外部依存関係を導入しないことにしました。

おそらく、これらのプロジェクトの主な違いは抽象化を構築するためのアプローチの違いです。

> The main goal of RxSwift project is to provide environment agnostic compositional computation glue abstracted in the form of observable sequences. 

RxSwiftプロジェクトの主な目標は、observableシーケンスの形で環境にとらわれないcompositional computation glueの抽象化を提供することです。  
私達はその後特定のプラットフォームでRxSwiftを使用する体験を改善することを目指しています。  
RxCocoaはより実用的な抽象化を構築し、Foundation/Cocoa/UKitフレームワークをラップするためにこれらの一般的な計算を使用しています。  
それは、他のライブラリーはRxSwiftが提供する `Driver`、`ControlProperty`、`ControlEvent`及びその他など一般的な計算エンジンへのコンテキストとセマンティクスを与えることを意味します。  

利点の一つとして単一の概念でこれら全ての抽象化を表現できることがあります。 _observableシーケンス_ は、それらの上に構築された全ての計算抽象化と同じ基本的な方法で構成可能であるということです。  
それらは全て、同じ契約に従って同じインターフェースを実装します。

フレキシブルなサブスクリプション(リソース)はストラテジーを共有する、またはビルドインのいずれかを使用することで簡単に作成することができます:  
`share`, `shareReplay`, `publish`, `multicast`, `shareReplayLatestWhileConnected`...


このライブラリはまた、微調整可能な同時実行モデルを提供しています。
コンカレントスケジューラーを使用している場合、observableシーケンスオペレーターはシーケンスのプロパティを保持します。
同じobservableシーケンスオペレーターは最適なシリアルスケジューラーの検出方法を知っているでしょう。
ReactiveCocoaはシリアルスケジューラーのみに許可されたより限定された同時実行モデルを持っています。

マルチスレッドプログラミングは本当に難しく、非自明なループを検出するのは更に難しくなります。  
これは全てのオペレーターがフォールトトレラントな方法で構築されている理由です。  
要素の処理をしている間に要素生成が発生した場合でも、オペレーターは状況をハンドルしてデッドロックを防ごうとするでしょう。
それは最悪のケースのプログラミングエラーであるスタックオーバーフローを引き起こすことを意味します。  
しかしユーザーが手動でアプリを殺す必要はありません、あなたはエラー報告システムでクラッシュレポートを取得し、  
問題を発見して修正できます。
