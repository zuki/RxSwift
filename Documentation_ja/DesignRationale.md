設計の論拠
================

## エラータイプはなぜジェネリクスでないのか

```Swift
enum Event<Element>  {
    case Next(Element)      // シーケンスの次の要素
    case Error(ErrorType)   // シーケンスはエラーで失敗
    case Completed          // シーケンスは正常に終了
}
```

`ErrorType`をジェネリクスにした場合の利点と欠点を考察しよう。

ジェネリクスなエラータイプにすると、2つのobservable間で新たなインピーダンスミスマッチを生ずじます。

以下の2つがあるとします:

`Observable<String, E1>` および `Observable<String, E2>`

結果として得られるエラータイプが何になるかがわからないとこれらを使って行えることは多くありません。

それは`E1`なのか`E2`なのか。あるいは別の`E3`なのか。そのため、このインピーダンスミスマッチを解決するのみのために新たなオペレータが必要になります。

これは確実に構成プロパティを阻害します。そして、明らかにRxはなぜシーケンスが失敗したかについてはケアせず、通常単にobservableチェインの下流に失敗を送るだけです。

オペレータが何らかの内部エラーで失敗した場合に想定されるさらなる問題が存在します。そのような場合、結果としてのエラーを構成できず、失敗を報告できなくなるという問題です。

OK、それは無視して、エラーを出力しないシーケンスをモデル化するのにそれを利用できると仮定しましょう。それがその目的にとって役立つように思えますか。

まあいいでしょう、そうなる可能性はあります。しかし、エラーを出力しないシーケンスをなぜ使用したいと思うか考えてみましょう。

その明らかな応用例の一つはUI全体を動作させるUIレイヤーにおける永続的ストリームに対するものです。しかしそのケースを考えると、実際はコンパイラを使ってシーケンスがエラーを出力しないことを証明するだけでは不十分であり、他のプロパティも証明する必要があります。たとえば、要素が`MainScheduler`でオブザーブされているかなどです。

実際に必要なのはシーケンス（`Observables`）の特性を証明する一般的な方法です。そして多くのプロパティに関心を持つでしょう。たとえば次のようなプロパティです。

* シーケンスは有限時間で終了する（サーバーサイド）
* シーケンスはただ一つの要素を含んでいる（なんかの計算を行っている場合）
* シーケンスはエラーを出力せず、決して終了しない。要素はmain scheduler上で配信される（UI）
* シーケンスはエラーを出力せず、決して終了しない。要素はmain scheduler上で配信され、refcountによる共有がされている（UI）
* シーケンスはエラーを出力せず、決して終了しない。要素は指定したbackground schedulerじょうで配信される（オーディオエンジン）

実際に欲しいものはobservableシーケンス向けの特性システムを持つ一般的なコンパイラと必要とするプロパティ向けの一連の不変なオペレータです。

私見によればその良いアナロジーは次のようなものです。

```
1, 3.14, e, 2.79, 1 + 1i      <->    Observable<E>
1m/s, 1T, 5kg, 1.3 pounds     <->    Errorless observable, UI observable, Finite observable ...
```

Swiftでそれを行うには、observableの合成または継承のいずれかを使うことにより多くの方法があります。

ユニットシステムを使用するもう一つの利点はそのUIコードが同一のスケジュラーじょうで実行していることを証明でき、すべての変換用にロックなしのオペレータを使用できることです。

Rxはすでに単一シーケンスオペレータにはロックがなく、残りのロックはすべてステートフルなコンポーネント（すなわちUI）ですので、それは実用上は残りのすべてのロックをRxコードから取り除くことになり、ロックレスなRxコードを強いるコンパイラを作成することになります。

したがって、私見によれば、他の方法よりクリーンでなくRxの構成的セマンティクスを保持できない型付けされたエラーを使用する利点はまったく存在しません。また、その他の方法も他の多量の利点を持っています。
